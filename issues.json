[

  {
    "url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/2",
    "repository_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake",
    "labels_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/2/comments",
    "events_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/2/events",
    "html_url": "https://github.com/kazuho/draft-kazuho-quic-authenticated-handshake/issues/2",
    "id": 388367720,
    "node_id": "MDU6SXNzdWUzODgzNjc3MjA=",
    "number": 2,
    "title": "Can the hidden server access the ESNI private key?",
    "user": {
      "login": "huitema",
      "id": 7464128,
      "node_id": "MDQ6VXNlcjc0NjQxMjg=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7464128?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huitema",
      "html_url": "https://github.com/huitema",
      "followers_url": "https://api.github.com/users/huitema/followers",
      "following_url": "https://api.github.com/users/huitema/following{/other_user}",
      "gists_url": "https://api.github.com/users/huitema/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huitema/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huitema/subscriptions",
      "organizations_url": "https://api.github.com/users/huitema/orgs",
      "repos_url": "https://api.github.com/users/huitema/repos",
      "events_url": "https://api.github.com/users/huitema/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huitema/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 8,
    "created_at": "2018-12-06T19:41:59Z",
    "updated_at": "2018-12-07T07:17:11Z",
    "closed_at": null,
    "author_association": "NONE",
    "body": "The ESNI procedure involve the client, the fronting server and the hidden server. The client gets the ESNI public key, and uses it to encrypt the \"real SNI\". The fronting server decrypts the ESNI using the corresponding private key, obtains the \"real SNI\", and forwards the connection to the hidden server. There is no need for the hidden server to know the private ESNI key. If there was such a need, all services that share the fronting server would need to know the key, which would greatly increase the risks of leak.\r\n\r\nThe spec computes the AAD as:\r\n```\r\n   initial_auth_secret = HKDF-Expand-Label(Zx, \"quic initial auth\",\r\n                                           Hash(ESNIContents), 16)\r\n```\r\nThis requires access to the ESNI content. This is not a problem for the client because it chose that content, but it is not obvious for the hidden server, which does not have access to the ESNI private key. How is that supposed to work?\r\n"
  },
  {
    "url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/1",
    "repository_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake",
    "labels_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/1/comments",
    "events_url": "https://api.github.com/repos/kazuho/draft-kazuho-quic-authenticated-handshake/issues/1/events",
    "html_url": "https://github.com/kazuho/draft-kazuho-quic-authenticated-handshake/issues/1",
    "id": 388314394,
    "node_id": "MDU6SXNzdWUzODgzMTQzOTQ=",
    "number": 1,
    "title": "AEAD or special frame?",
    "user": {
      "login": "huitema",
      "id": 7464128,
      "node_id": "MDQ6VXNlcjc0NjQxMjg=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7464128?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/huitema",
      "html_url": "https://github.com/huitema",
      "followers_url": "https://api.github.com/users/huitema/followers",
      "following_url": "https://api.github.com/users/huitema/following{/other_user}",
      "gists_url": "https://api.github.com/users/huitema/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/huitema/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/huitema/subscriptions",
      "organizations_url": "https://api.github.com/users/huitema/orgs",
      "repos_url": "https://api.github.com/users/huitema/repos",
      "events_url": "https://api.github.com/users/huitema/events{/privacy}",
      "received_events_url": "https://api.github.com/users/huitema/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [

    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 9,
    "created_at": "2018-12-06T17:18:11Z",
    "updated_at": "2018-12-08T08:16:49Z",
    "closed_at": null,
    "author_association": "NONE",
    "body": "You propose to use the ESNI secret as input to the key generation for the \"Initial\" context. This is a significant departure from standard QUIC, and I am concerned that we have a circular dependency. Servers can only assess the ESNI content after receiving the Initial content, but receiving it requires decrypting the data. My implementation uses a standard call to the AEAD library for that. The ESNI content is not known at the time of the AEAD call, and the AEAD checksum is going to not verify.\r\n\r\nThere are several ways out of that, but I think the simplest way is to add some kind of ESNI proof in a the server response. I don't think it can be sent as a TLS extension, because in server's first flight the extension are encrypted. QUIC will send them as handshake packets, which means they cannot be used to protect the Initial packet. The simplest solution is probably to invent an \"ESNI proof\" frame, that should be conveyed in the Initial packet if the ESNI extension is accepted. "
  }

]
